#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>

using namespace std;

const long long inf = 1e18; 

vector<long long> dijkstra(int N, int start_node, const vector<vector<pair<int, int>>>& adj_list) {
    vector<long long> distance(N + 1, inf);
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;

    distance[start_node] = 0;
    pq.push({0, start_node});

    while (!pq.empty()) {
        long long dist = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (dist > distance[u]) 
            continue;

        for (auto it : adj_list[u]) {
            int weight = it.first;
            int v = it.second;

            if (distance[u] + weight < distance[v]) {
                distance[v] = distance[u] + weight;
                pq.push({distance[v], v});
            }
        }
    }
    return distance; 
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N, M, S, T;
    if (!(cin >> N >> M >> S >> T))
        return 0;

    vector<vector<pair<int, int>>> adj_list(N + 1);
    for (int i = 0; i < M; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        adj_list[u].push_back({w, v}); 
    }

    
    vector<long long> dist_alice = dijkstra(N, S, adj_list);
    vector<long long> dist_bob = dijkstra(N, T, adj_list);
    
    long long min_time = inf;
    int meeting_node = -1;

    for (int i = 1; i <= N; i++) {
        if (dist_alice[i] != inf && dist_bob[i] != inf) {
            long long meeting_time = max(dist_alice[i], dist_bob[i]);
            
            if (meeting_time < min_time) {
                min_time = meeting_time;
                meeting_node = i;
            }
        }
    }
    
    if (meeting_node == -1) {
        cout << -1 << endl;
    } 
    else {
        cout << min_time << " " << meeting_node << endl;
    }

    return 0;
}